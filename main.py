from tools.courses import get_courses
from graph.compass_graph import build_compass_graph

# This is the main function that runs the Compass graph and prints the resulting schedule and explanation.
def main():
    graph = build_compass_graph()

    state = {
        "courses": get_courses(),
        "priorities": [],
        "schedule": [],
        "explanation": None,
        "available_minutes": 180,
        "explain": True
    }

    result = graph.invoke(state)

    # Printing the priorities and schedule generated by the graph.
    print("\nPRIORITIES")
    for item in result["priorities"]:
        c = item["course"]
        print(f"{c.name} | priority {item['priority_score']}")

    print("\nSCHEDULE")
    for item in result["schedule"]:
        print(f"{item['course'].name} → {item['minutes']} min")

    if result.get("explanation"):
        print("\nEXPLANATION")
        print(result["explanation"])

if __name__ == "__main__":
    main()


"""
PREVIOUS TEST CODE:

statuses = [assess_course_status(c) for c in courses] # Assessing the status of each course.
deadline_reports = [assess_deadline(c) for c in courses if assess_deadline(c)] # Assessing the deadlines of each course.

for s in statuses:
    print(
        s["course"].name,
        "Risk:", s["risk_score"],
        "Days Idle:", s["days_idle"]
    )

# Next, I will print out the deadline details of each course to verify the deadline agent's functionality.
for d in deadline_reports:
    print(
        d["course"].name,
        "Due in:", d["days_left"], "days,",
        "Urgency:", d["urgency"]
    )


    for course in courses:
    assess_course_status(course) # Assessing the status of each course.
    assess_deadline(course) # Assessing the deadlines of each course.

task_plan = plan_tasks(courses) # Planning the tasks based on the analysis from the agents.

print("PRIORITIES")
for item in task_plan:
    course = item["course"]
    print(
        f"{course.name} | "
        f"deadline: {course.deadline_urgency} | "
        f"risk: {course.risk_score} | "
        f"priority_score: {item['priority_score']}"
    )

# Now we will allocate time based on the planned tasks, risk scores, and deadline urgencies.

schedule = allocate_time(task_plan, AVAILABLE_MINUTES)

print("\nSCHEDULING")
total = 0
for s in schedule:
    c = s["course"]
    print(
        f"{c.name:<25} → "
        f"{s['blocks']} blocks "
        f"({s['minutes']} min)"
    )
    total += s["minutes"]

print(f"\nTotal scheduled: {total} / {AVAILABLE_MINUTES} minutes")
AVAILABLE_MINUTES = 180 # Setting the total available time in minutes for testing.

def main():
    courses = get_courses() # Getting the list of courses.
    result = run_supervisor(courses, available_minutes=180) # Running the supervisor agent with 180 available minutes.

    # The run_supervisor function returns a dictionary with two keys "priorities" and "schedule".
    # Here I am printing out the courses along with their priority scores as well as the recommended schedule, all based on the assessments of all the agents.
    print("\nPRIORITIES")
    for item in result["priorities"]:
        c = item["course"]
        print(f"{c.name} | priority {item['priority_score']}")

    print("\nSCHEDULE")
    for s in result["schedule"]:
        print(f"{s['course'].name} → {s['minutes']} min")

    # Getting and printing an explanation of the entire plan including priorities and schedule using the LLM explainer.
    explanation = explain_plan(result["priorities"], result["schedule"])
    print(explanation)

if __name__ == "__main__":
    main()

"""



